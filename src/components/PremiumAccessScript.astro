---
// Landing Script Component
// Handles complex ad loading and presentation logic
---

<script>
  // @ts-nocheck
  (function () {
    "use strict";

    // ===================================================================================
    // MODULE: UTILITIES & CONFIGURATION
    // ===================================================================================
    const utils = {
      consoleStyles: {
        progress:
          "color: #00ffff; background: linear-gradient(45deg, #0c4a6e, #075985); padding: 2px 6px; border-radius: 4px; font-weight: bold;",
        process:
          "color: #ffd700; background: linear-gradient(45deg, #92400e, #b45309); padding: 2px 6px; border-radius: 4px; font-weight: bold;",
        info: "color: #87ceeb; background: linear-gradient(45deg, #1e40af, #3b82f6); padding: 2px 6px; border-radius: 4px; font-weight: bold;",
        success:
          "color: #90ee90; background: linear-gradient(45deg, #166534, #22c55e); padding: 2px 6px; border-radius: 4px; font-weight: bold;",
        error:
          "color: #ffb6c1; background: linear-gradient(45deg, #991b1b, #dc2626); padding: 2px 6px; border-radius: 4px; font-weight: bold;",
      },
    };

    const config = {
      LOADING_DURATION: 8000,
      LOADING_INTERVAL: 200,
      ADX_SLOT_ID: "admanager-display-ad",
      RETRY_TIMEOUTS: [5000, 3000, 3000],
      BACK_URL_1: "/landing/premium-ai-apps?gad_source=5",
      AD_FINALIZE_DELAY: 500, // Delay before finalizing ad position
      REWARDED_SLOT_PATH:
        window.REWARDED_SLOT_PATH || "/23279042541/interstitial", // Fallback, populated by parent
      REWARDED_INIT_TIMEOUT: 5000, // Timeout to force init rewarded if display ad hasn't filled
    };

    const state = {
      progress: 0,
      progressInterval: null,
      statusIndex: 0,
      speedIndex: 0,
      decisionMade: false,
      winningAdElement: null,
      adxAttemptCount: 0,
      adxRetryTimer: null,
      adSlotObject: null,
      loadingComplete: false,
      originalAdStyles: null, // Store original ad styles
      displayAdFilled: false, // Track if display ad has filled
    };

    // Rewarded ad state (separate from display ad state)
    const rewardedState = {
      initialized: false,
      ready: false,
      event: null,
      rewardedSlot: null,
      popupTimer: null,
    };

    const elements = {
      body: null,
      progressSection: null,
      successSection: null,
      progressBar: null,
      progressText: null,
      progressPercent: null,
      statusText: null,
      downloadSpeed: null,
      timeRemaining: null,
      startButton: null,
      adxContainer: null,
    };

    // Progress statuses for the loading screen
    const statuses = [
      "Initializing package...",
      "Connecting to server...",
      "Verifying package integrity...",
      "Starting package...",
      "Downloading package files...",
      "Processing AI applications...",
      "Optimizing package...",
      "Download Ready!",
    ];

    const speeds = [
      "2.1 MB/s",
      "3.4 MB/s",
      "2.8 MB/s",
      "4.2 MB/s",
      "3.1 MB/s",
      "2.9 MB/s",
      "3.7 MB/s",
      "4.5 MB/s",
    ];

    // ===================================================================================
    // MODULE: Device Detection
    // ===================================================================================
    const uap = new UAParser();
    const isMobile = uap.getResult().device.type === "mobile";

    // ===================================================================================
    // MODULE: Ad Management (Retry Logic)
    // ===================================================================================
    const adManager = {
      init() {
        console.log(
          "%c[ADS] Initializing AdX with Retry Logic...",
          utils.consoleStyles.info,
        );
        // Menunggu googletag siap, lalu memulai proses
        googletag.cmd.push(() => {
          // Cari slot yang sudah didefinisikan di <head>
          const allSlots = googletag.pubads().getSlots();
          state.adSlotObject = allSlots.find(
            (slot) => slot.getSlotElementId() === config.ADX_SLOT_ID,
          );

          if (!state.adSlotObject) {
            console.error(
              `%c[ADS] Ad slot with ID '${config.ADX_SLOT_ID}' not found.`,
              utils.consoleStyles.error,
            );
            return;
          }

          // Siapkan listener untuk hasil render iklan
          googletag
            .pubads()
            .addEventListener(
              "slotRenderEnded",
              this.handleSlotRender.bind(this),
            );

          // Mulai percobaan pertama. Permintaan awal sudah dibuat oleh googletag.display() di HTML.
          // Kita hanya perlu menyetel timeout untuknya.
          this.startAttemptTimeout();
        });
      },

      handleSlotRender(event) {
        if (state.decisionMade) return;
        if (event.slot.getSlotElementId() !== config.ADX_SLOT_ID) return;

        // Jika ada respons, batalkan timeout untuk percobaan saat ini
        clearTimeout(state.adxRetryTimer);
        state.adxAttemptCount++;

        // Jika slot terisi (sukses)
        if (!event.isEmpty) {
          console.log(
            `%c[ADS] AdX FILLED on attempt #${state.adxAttemptCount}. Process complete.`,
            utils.consoleStyles.success,
          );
          state.winningAdElement = elements.adxContainer;
          state.decisionMade = true;
          state.displayAdFilled = true;
          // Store original styles before any modifications
          state.originalAdStyles = {
            position: state.winningAdElement.style.position,
            top: state.winningAdElement.style.top,
            left: state.winningAdElement.style.left,
            transform: state.winningAdElement.style.transform,
            zIndex: state.winningAdElement.style.zIndex,
            transition: state.winningAdElement.style.transition,
          };

          // Handle different scenarios based on loading state
          if (state.progress < 100) {
            // Loading still in progress - force complete
            loadingScreen.forceComplete(false);
          } else if (
            state.loadingComplete &&
            elements.successSection &&
            !elements.successSection.classList.contains("hidden")
          ) {
            // Loading already complete and success section visible - position ad now
            console.log("[ADS] Late ad load detected. Positioning ad...");
            setTimeout(() => {
              adManager.finalizeAdPosition();
            }, config.AD_FINALIZE_DELAY);
          }
        }
        // Jika slot kosong, coba lagi (jika masih ada jatah)
        else {
          console.log(
            `%c[ADS] AdX UNFILLED on attempt #${state.adxAttemptCount}.`,
            utils.consoleStyles.error,
          );
          this.tryNextAttempt();
        }
      },

      tryNextAttempt() {
        if (state.adxAttemptCount >= config.RETRY_TIMEOUTS.length) {
          console.log(
            "%c[ADS] All retry attempts failed. Hiding ad container.",
            utils.consoleStyles.error,
          );
          if (elements.adxContainer)
            elements.adxContainer.style.display = "none";
          state.decisionMade = true;

          // Notify loading complete with failure flag
          if (state.progress < 100) {
            loadingScreen.forceComplete(true);
          }
          return;
        }

        console.log(
          `%c[ADS] Starting attempt #${state.adxAttemptCount + 1}...`,
          utils.consoleStyles.process,
        );
        this.startAttemptTimeout();
        googletag.pubads().refresh([state.adSlotObject]);
      },

      startAttemptTimeout() {
        const currentAttemptIndex = state.adxAttemptCount;
        const timeoutDuration = config.RETRY_TIMEOUTS[currentAttemptIndex];

        state.adxRetryTimer = setTimeout(() => {
          console.log(
            `%c[ADS] Attempt #${currentAttemptIndex + 1} TIMED OUT after ${timeoutDuration / 1000}s.`,
            utils.consoleStyles.error,
          );
          state.adxAttemptCount++;
          this.tryNextAttempt();
        }, timeoutDuration);
      },

      finalizeAdPosition() {
        if (!state.winningAdElement) {
          console.error("Cannot finalize ad position: missing ad element");
          return;
        }

        console.log("[ADS] Finalizing ad position - restoring to original.");

        // Restore original styles (return ad to original position)
        if (state.originalAdStyles) {
          state.winningAdElement.style.position =
            state.originalAdStyles.position || "";
          state.winningAdElement.style.top = state.originalAdStyles.top || "";
          state.winningAdElement.style.left = state.originalAdStyles.left || "";
          state.winningAdElement.style.transform =
            state.originalAdStyles.transform || "";
          state.winningAdElement.style.zIndex =
            state.originalAdStyles.zIndex || "";
          state.winningAdElement.style.transition =
            state.originalAdStyles.transition || "";
        } else {
          // Fallback: remove inline styles to restore original
          state.winningAdElement.style.position = "";
          state.winningAdElement.style.top = "";
          state.winningAdElement.style.left = "";
          state.winningAdElement.style.transform = "";
          state.winningAdElement.style.zIndex = "";
          state.winningAdElement.style.transition = "";
        }

        console.log("[ADS] Ad restored to original position.");
      },
    };

    // ===================================================================================
    // MODULE: Loading Screen Management
    // ===================================================================================
    const loadingScreen = {
      init() {
        // Start the progress animation after a short delay
        setTimeout(() => {
          this.startProgress();
        }, 1000);
      },

      startProgress() {
        const increment =
          100 / (config.LOADING_DURATION / config.LOADING_INTERVAL);

        state.progressInterval = setInterval(() => {
          state.progress += Math.random() * 8 + 2; // Random increment between 2-10

          if (state.progress >= 100) {
            state.progress = 100;
            this.completeLoading();
          } else {
            this.updateProgress();
          }
        }, config.LOADING_INTERVAL);
      },

      updateProgress() {
        // Update progress bar
        if (elements.progressBar) {
          elements.progressBar.style.width = state.progress + "%";
        }

        if (elements.progressPercent) {
          elements.progressPercent.textContent =
            Math.round(state.progress) + "%";
        }

        // Update status text based on progress
        if (state.progress > state.statusIndex * 12) {
          if (elements.statusText && state.statusIndex < statuses.length) {
            elements.statusText.textContent = statuses[state.statusIndex];
          }
          state.statusIndex = Math.min(
            state.statusIndex + 1,
            statuses.length - 1,
          );
        }

        // Update download speed periodically
        if (state.progress % 15 < 2) {
          if (elements.downloadSpeed) {
            elements.downloadSpeed.textContent =
              speeds[state.speedIndex % speeds.length];
          }
          state.speedIndex++;
        }

        // Update time remaining
        const remaining = Math.max(0, Math.round((100 - state.progress) / 3));
        if (elements.timeRemaining) {
          elements.timeRemaining.textContent =
            remaining > 0 ? `${remaining}s` : "Almost done...";
        }

        // Update progress text based on progress percentage
        if (elements.progressText) {
          if (state.progress < 20) {
            elements.progressText.textContent = "Preparing download...";
          } else if (state.progress < 40) {
            elements.progressText.textContent = "Downloading package...";
          } else if (state.progress < 60) {
            elements.progressText.textContent = "Processing files...";
          } else if (state.progress < 80) {
            elements.progressText.textContent = "Optimizing package...";
          } else if (state.progress < 100) {
            elements.progressText.textContent = "Finalizing download...";
          }
        }
      },

      completeLoading() {
        clearInterval(state.progressInterval);
        state.loadingComplete = true;

        if (elements.progressText) {
          elements.progressText.textContent = "Download complete!";
        }

        // Show success section after a short delay
        setTimeout(() => {
          this.showSuccessSection();
        }, 1000);
      },

      forceComplete(isFailure) {
        // Prevent multiple forced completions
        if (state.loadingComplete) {
          console.log("[Loading] Already completed, ignoring force complete.");
          return;
        }

        // Force progress to 100% and complete loading
        state.progress = 100;
        this.updateProgress();
        this.completeLoading();
      },

      showSuccessSection() {
        if (elements.progressSection) {
          elements.progressSection.classList.add("hidden");
        }

        if (elements.successSection) {
          elements.successSection.classList.remove("hidden");

          // If we have a winning ad, position it after ensuring start button is visible
          if (state.winningAdElement && elements.startButton) {
            // Wait a bit to ensure the success section is fully rendered
            setTimeout(() => {
              adManager.finalizeAdPosition();
            }, config.AD_FINALIZE_DELAY);
          }
        }

        // Re-enable scrolling
        if (elements.body) {
          elements.body.style.overflow = "auto";
        }
      },
    };

    // ===================================================================================
    // MODULE: Rewarded Ad Management
    // ===================================================================================
    const rewardedAdManager = {
      init() {
        if (rewardedState.initialized) return;
        rewardedState.initialized = true;
        console.log(
          "%c[REWARDED] ğŸš€ Initializing rewarded ads...",
          utils.consoleStyles.info,
        );

        googletag.cmd.push(() => {
          rewardedState.rewardedSlot = googletag.defineOutOfPageSlot(
            config.REWARDED_SLOT_PATH,
            googletag.enums.OutOfPageFormat.REWARDED,
          );

          if (rewardedState.rewardedSlot) {
            rewardedState.rewardedSlot.addService(googletag.pubads());

            googletag
              .pubads()
              .addEventListener("rewardedSlotReady", (event) => {
                rewardedState.ready = true;
                rewardedState.event = event;
                console.log(
                  "%c[REWARDED] âœ… Rewarded ad ready!",
                  utils.consoleStyles.success,
                );
              });

            googletag.pubads().addEventListener("rewardedSlotGranted", () => {
              console.log(
                "%c[REWARDED] ğŸ Reward granted! Proceeding to download...",
                utils.consoleStyles.success,
              );
              downloadHandler.executeDownload();
            });

            googletag.pubads().addEventListener("rewardedSlotClosed", () => {
              console.log(
                "%c[REWARDED] âŒ Rewarded ad closed without completing",
                utils.consoleStyles.error,
              );
              // Block download & show popup warning
              this.showWarningPopup();
              // Reset rewarded state so it can be reloaded on next click
              this.resetAndReload();
            });

            googletag.pubads().refresh([rewardedState.rewardedSlot]);
            console.log(
              "%c[REWARDED] ğŸ”ƒ Rewarded slot refreshed",
              utils.consoleStyles.process,
            );
          } else {
            console.log(
              "%c[REWARDED] âŒ Failed to create rewarded slot",
              utils.consoleStyles.error,
            );
          }
        });
      },

      resetAndReload() {
        // Reset state for next attempt
        rewardedState.ready = false;
        rewardedState.event = null;
        rewardedState.initialized = false;

        // Destroy old slot and re-init
        if (rewardedState.rewardedSlot) {
          googletag.cmd.push(() => {
            googletag.destroySlots([rewardedState.rewardedSlot]);
            rewardedState.rewardedSlot = null;
            console.log(
              "%c[REWARDED] ğŸ”„ Slot destroyed. Will re-init on next click.",
              utils.consoleStyles.process,
            );
            // Re-initialize immediately so it's ready for next click
            this.init();
          });
        }
      },

      show() {
        if (
          rewardedState.ready &&
          rewardedState.event &&
          rewardedState.event.makeRewardedVisible
        ) {
          console.log(
            "%c[REWARDED] ğŸ¬ Showing rewarded ad...",
            utils.consoleStyles.info,
          );
          rewardedState.event.makeRewardedVisible();
        } else {
          console.log(
            "%c[REWARDED] âš ï¸ Rewarded ad not ready, proceeding to download directly...",
            utils.consoleStyles.error,
          );
          downloadHandler.executeDownload();
        }
      },

      showWarningPopup() {
        // Remove existing popup if any
        const existing = document.getElementById("rewarded-warning-popup");
        if (existing) existing.remove();
        if (rewardedState.popupTimer) clearTimeout(rewardedState.popupTimer);

        const popup = document.createElement("div");
        popup.id = "rewarded-warning-popup";
        popup.innerHTML = `
          <div style="
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #991b1b, #dc2626);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            z-index: 100002;
            box-shadow: 0 8px 32px rgba(220, 38, 38, 0.4);
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 90vw;
            text-align: center;
            animation: popupSlideUp 0.3s ease-out;
          ">
            <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='currentColor' style='width:18px;height:18px;flex-shrink:0;'>
              <path fill-rule='evenodd' d='M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z' clip-rule='evenodd'/>
            </svg>
            <span>Please watch the ad completely to unlock download</span>
          </div>
        `;
        document.body.appendChild(popup);

        // Add animation style if not exists
        if (!document.getElementById("rewarded-popup-styles")) {
          const style = document.createElement("style");
          style.id = "rewarded-popup-styles";
          style.textContent = `
            @keyframes popupSlideUp {
              from { opacity: 0; transform: translateX(-50%) translateY(20px); }
              to { opacity: 1; transform: translateX(-50%) translateY(0); }
            }
            @keyframes popupFadeOut {
              from { opacity: 1; transform: translateX(-50%) translateY(0); }
              to { opacity: 0; transform: translateX(-50%) translateY(20px); }
            }
          `;
          document.head.appendChild(style);
        }

        // Auto-hide after 4 seconds
        rewardedState.popupTimer = setTimeout(() => {
          const el = document.getElementById("rewarded-warning-popup");
          if (el) {
            el.firstElementChild.style.animation =
              "popupFadeOut 0.3s ease-in forwards";
            setTimeout(() => el.remove(), 300);
          }
        }, 4000);
      },

      // Trigger rewarded init after display ad is filled or timeout
      startInitWatcher() {
        let rewardedInitDone = false;
        let rewardedInitTimer = null;

        const tryInit = () => {
          if (rewardedInitDone) return;
          if (state.displayAdFilled) {
            console.log(
              "%c[REWARDED] âœ… Display ad filled! Initializing rewarded ads immediately.",
              utils.consoleStyles.success,
            );
            rewardedInitDone = true;
            if (rewardedInitTimer) clearTimeout(rewardedInitTimer);
            this.init();
          }
        };

        // Check every 1s
        const checkInterval = setInterval(() => {
          if (rewardedInitDone) {
            clearInterval(checkInterval);
            return;
          }
          tryInit();
        }, 1000);

        // Fallback: Force init after timeout
        rewardedInitTimer = setTimeout(() => {
          if (!rewardedInitDone) {
            console.log(
              "%c[REWARDED] â° Timeout reached. Forcing rewarded ads init.",
              utils.consoleStyles.process,
            );
            rewardedInitDone = true;
            clearInterval(checkInterval);
            this.init();
          }
        }, config.REWARDED_INIT_TIMEOUT);
      },
    };

    // ===================================================================================
    // MODULE: Navigation Manager
    // ===================================================================================
    const navigationManager = {
      isRedirecting: false,

      init() {
        try {
          history.pushState({ trap: "on" }, "", window.location.href);
          window.addEventListener("popstate", this.handlePopState.bind(this));
        } catch (e) {
          console.error("Failed to init back-button trap", e);
        }
      },

      handlePopState(e) {
        if (this.isRedirecting) return;

        // Always try to redirect on popstate
        this.isRedirecting = true;
        history.pushState({ trap: "on" }, "", window.location.href);
        // window.location.replace(config.BACK_URL_1);
      },
    };

    // ===================================================================================
    // MODULE: Download Button Handler
    // ===================================================================================
    const downloadHandler = {
      init() {
        if (!elements.startButton) return;

        elements.startButton.addEventListener("click", (e) => {
          e.preventDefault();
          console.log(
            "%c[REWARDED] ğŸ”˜ Download button clicked, attempting rewarded ad...",
            utils.consoleStyles.info,
          );

          if (rewardedState.initialized) {
            rewardedAdManager.show();
          } else {
            console.log(
              "%c[REWARDED] â„¹ï¸ Rewarded ads not initialized (not eligible). Proceeding to download...",
              utils.consoleStyles.process,
            );
            downloadHandler.executeDownload();
          }
        });
      },

      executeDownload() {
        const urlParams = new URLSearchParams(window.location.search);
        const downloadParam = urlParams.get("download");

        if (downloadParam) {
          // Redirect to the download page with the parameter
          window.location.href = `/download/${downloadParam}?gad_source=1`;
        } else {
          // Fallback behavior
          window.location.href = `/terabox-access`;
        }

        // Update button to show success
        elements.startButton.innerHTML =
          '<svg class="mr-3 h-6 w-6 md:h-8 md:w-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
          '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>' +
          "</svg><span>DOWNLOADED SUCCESSFULLY!</span>";

        // Update button styling
        elements.startButton.classList.remove(
          "hover:scale-105",
          "hover:from-yellow-400",
          "hover:to-yellow-500",
        );
        elements.startButton.classList.add(
          "bg-gradient-to-r",
          "from-green-500",
          "to-green-600",
          "border-green-400",
        );
      },
    };

    // ===================================================================================
    // INITIALIZATION
    // ===================================================================================
    function init() {
      document.addEventListener("DOMContentLoaded", () => {
        // â”€â”€â”€ Cache DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        elements.body = document.body;
        elements.progressSection = document.getElementById("progressSection");
        elements.successSection = document.getElementById("successSection");
        elements.progressBar = document.getElementById("progressBar");
        elements.progressText = document.getElementById("progressText");
        elements.progressPercent = document.getElementById("progressPercent");
        elements.statusText = document.getElementById("statusText");
        elements.downloadSpeed = document.getElementById("downloadSpeed");
        elements.timeRemaining = document.getElementById("timeRemaining");
        elements.startButton = document.getElementById("startButton");
        elements.adxContainer = document.getElementById("adx-container");

        // â”€â”€â”€ Eligibility test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const urlParams = new URLSearchParams(window.location.search);
        const hasAdParams =
          urlParams.has("gclid") || urlParams.has("gad_source");
        const isEligibleAds = hasAdParams && isMobile; // iklan hanya jika punya salah satu param + mobile

        if (!isEligibleAds) {
          console.log(
            "No ad params OR not mobile. Loading will proceed without ads.",
          );
        }

        // â”€â”€â”€ Global loading preparations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.scrollTo(0, 0);
        // Note: scroll lock removed for eligible users

        // â”€â”€â”€ Init modules â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        navigationManager.init();
        loadingScreen.init(); // selalu tampilkan loading screen
        downloadHandler.init(); // selalu jalankan download handler

        if (isEligibleAds) {
          adManager.init(); // hanya jalankan jika eligible
          rewardedAdManager.startInitWatcher(); // Start watching for display ad fill to init rewarded
        }
      });
    }

    init();
  })();
</script>
